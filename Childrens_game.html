<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alphabet Drag Spell</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        /* General Setup */
        :root {
            --bg-color-light: #f0f4f7; /* Light Blue/Gray Background */
            --bg-color-dark: #0f1724; /* Dark background */
            --text-light: #111827;
            --text-dark: #e6eef8;
            --card-light: linear-gradient(145deg, #ffffff, #f0f0f0);
            --card-dark: linear-gradient(145deg, #0b1220, #112033);
            --tile-bg-light: #ffffff;
            --tile-bg-dark: #15202b;
            --slot-bg-light: #cfd8dc;
            --slot-bg-dark: #1f2a36;
            --accent-color: #f5a623; /* Orange/Hint */
            --primary-color: #4a90e2; /* Blue */
            --secondary-color: #7ed321; /* Green */
            --primary-color: #4a90e2; /* Blue */
            --secondary-color: #7ed321; /* Green */
            --accent-color: #f5a623; /* Orange/Hint */
            --bg-color: #f0f4f7; /* Light Blue/Gray Background */
            --tile-bg: #ffffff;
            --slot-bg: #cfd8dc;
        }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color-light);
            color: var(--text-light);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            text-align: center;
            user-select: none; /* Prevent text selection */
            transition: background-color 0.25s, color 0.25s;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        .game-container {
            width: 100%;
            max-width: 850px;
            background: var(--card-light);
            border-radius: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15), 0 10px 30px rgba(74, 144, 226, 0.1);
            padding: 40px;
            position: relative;
            animation: fadeInUp 0.6s ease-out;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .dark .game-container {
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6), 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        h1 {
            color: var(--primary-color);
            font-weight: 900;
            margin-bottom: 25px;
            font-size: 2.8rem;
            text-shadow: 0 2px 10px rgba(74, 144, 226, 0.2);
            letter-spacing: -0.5px;
        }

        /* Image and Word Slots Area */
        .display-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 30px;
        }

        /* Container for slots and hint button */
        .word-slots-and-hint {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px; /* Space between slots and button */
        }

        /* New styles for the self-contained image display */
        #wordImage {
            width: 150px;
            height: 150px;
            border-radius: 15px;
            border: 5px solid var(--accent-color);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            background-color: #fff;
            object-fit: cover;
        }
        /* Emoji fallback when image is missing or for stylistic preference */
        #wordEmoji {
            width: 150px;
            height: 150px;
            border-radius: 15px;
            border: 5px solid var(--accent-color);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            background-color: #fff;
            display: none; /* hidden until needed */
            align-items: center;
            justify-content: center;
            font-size: 72px;
            line-height: 1;
        }

        /* Dark mode styles */
        .dark {
            background-color: var(--bg-color-dark);
            color: var(--text-dark);
        }

        .dark .game-container {
            background: var(--card-dark);
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
        }

        .dark #wordImage,
        .dark #wordEmoji {
            background-color: var(--tile-bg-dark);
            border: 5px solid rgba(245,166,35,0.9);
        }

        .dark .letter-slot {
            background-color: var(--slot-bg-dark);
            color: var(--text-dark);
            border: 2px dashed rgba(74,144,226,0.3);
        }

        .dark .letter-tile {
            background-color: var(--tile-bg-dark);
            color: var(--text-dark);
            border-color: rgba(74,144,226,0.8);
        }

        .word-slots {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: clamp(6px, 1.5vw, 12px);
            flex-wrap: wrap;
            max-width: 100%;
            padding: 0 10px;
        }

        .letter-slot {
            width: clamp(40px, 8vw, 56px);
            height: clamp(50px, 10vw, 70px);
            background-color: var(--slot-bg);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1.5rem, 4vw, 2.2rem);
            color: #333;
            font-weight: 700;
            border: 2px dashed var(--primary-color);
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        /* Long word adjustment (applied via JS based on word length) */
        .word-slots.long-word .letter-slot {
            width: clamp(35px, 6vw, 48px);
            height: clamp(45px, 8vw, 60px);
            font-size: clamp(1.3rem, 3.5vw, 1.9rem);
        }

        .letter-slot.hovered {
            background-color: #c0d8f0;
            border: 2px solid var(--primary-color);
            transform: scale(1.05);
        }

        /* New Hint Display Style */
        #hintDisplay {
            min-height: 1.5rem; /* Ensure space even when empty */
            color: #6a6a6a;
            font-size: 1.2rem;
            font-weight: 700;
            text-align: center;
            margin-top: 5px; 
            border: 1px dashed #ccc;
            padding: 8px 15px;
            border-radius: 8px;
            background-color: #fff8e1; /* Light yellow background */
            transition: opacity 0.3s;
            opacity: 0; /* Hidden by default */
        }

        /* Hint Button Style */
        .hint-button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: 700;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.2s, transform 0.1s;
        }

        .hint-button:hover:not(:disabled) {
            background-color: #e5941c;
            transform: translateY(-2px);
        }

        .hint-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            filter: grayscale(50%);
        }

        /* Draggable Letter Tiles Area */
        .tile-tray {
            padding: 25px;
            border-top: 2px solid rgba(74, 144, 226, 0.2);
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 12px;
            background: linear-gradient(180deg, rgba(227, 232, 236, 0.5), rgba(227, 232, 236, 1));
            border-radius: 0 0 30px 30px;
            box-shadow: inset 0 4px 10px rgba(0, 0, 0, 0.05);
        }

        .dark .tile-tray {
            background: linear-gradient(180deg, rgba(26, 35, 50, 0.5), rgba(26, 35, 50, 1));
            border-top-color: rgba(74, 144, 226, 0.3);
            box-shadow: inset 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .letter-tile {
            width: clamp(55px, 10vw, 70px);
            height: clamp(55px, 10vw, 70px);
            background-color: var(--tile-bg);
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(2rem, 4.5vw, 2.6rem);
            color: var(--primary-color);
            font-weight: 900;
            cursor: grab;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            transition: transform 0.1s, box-shadow 0.1s;
            border: 3px solid var(--primary-color);
            touch-action: none;
            user-select: none;
        }

        /* Long word tiles (smaller) */
        .tile-tray.long-word .letter-tile {
            width: clamp(48px, 8vw, 62px);
            height: clamp(48px, 8vw, 62px);
            font-size: clamp(1.8rem, 4vw, 2.3rem);
        }

        .letter-tile:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
        }

        .letter-tile:active {
            cursor: grabbing;
            transform: scale(0.95);
        }

        .letter-tile.correct {
            background-color: var(--secondary-color);
            color: white;
            border-color: #5cb85c;
            animation: bounce 0.5s;
               touch-action: none; /* important for touch dragging */
               -ms-touch-action: none;
               user-select: none;
        }

        /* Message Box (unchanged) */
        #messageBox {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none; 
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .message-content {
            background: var(--tile-bg);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
            transform: scale(0.8);
            animation: popIn 0.3s forwards;
            max-width: 90%;
            min-width: 300px;
        }

        .message-content h2 {
            color: var(--secondary-color);
            font-size: 3rem;
            margin-top: 0;
            animation: textGlow 1s infinite alternate;
        }

        #nextButton {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.2rem;
            font-weight: 700;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        #nextButton:hover {
            background-color: #3b73b9;
            transform: translateY(-2px);
        }

        /* Animations (unchanged) */
        @keyframes popIn {
            to { transform: scale(1); }
        }

        @keyframes textGlow {
            from { text-shadow: 0 0 5px var(--secondary-color), 0 0 10px var(--secondary-color); }
            to { text-shadow: 0 0 10px var(--secondary-color), 0 0 20px var(--secondary-color); }
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        /* Responsive Adjustments */
        @media (max-width: 600px) {
            body {
                padding: 10px;
                align-items: flex-start;
            }
            
            .game-container {
                padding: 20px 12px;
                margin-top: 80px; /* Space for settings button */
                margin-bottom: 20px;
                border-radius: 25px;
                max-width: 100%;
            }
            h1 {
                font-size: 2rem;
                margin-bottom: 18px;
            }
            #wordImage, #wordEmoji { 
                width: clamp(180px, 45vw, 220px); 
                height: clamp(180px, 45vw, 220px); 
                font-size: clamp(90px, 22vw, 110px); 
                margin-bottom: 20px;
                margin-top: 10px;
                border-width: 4px;
            }
            .message-content h2 {
                font-size: 2rem;
            }
            .word-slots {
                gap: clamp(5px, 1.2vw, 9px);
                padding: 0 5px;
            }
            .tile-tray {
                gap: clamp(10px, 2.5vw, 14px);
                padding: 18px 12px;
                border-radius: 0 0 25px 25px;
            }
        }

        /* Portrait mobile - extra compact for long words */
        @media (max-width: 480px) and (orientation: portrait) {
            body {
                padding: 8px;
                align-items: flex-start;
            }
            .game-container {
                padding: 18px 10px;
                margin-top: 70px; /* Space for settings button */
                margin-bottom: 15px;
                border-radius: 20px;
            }
            h1 {
                font-size: 1.9rem;
                margin-bottom: 15px;
            }
            #wordImage, #wordEmoji { 
                width: clamp(160px, 42vw, 200px); 
                height: clamp(160px, 42vw, 200px); 
                font-size: clamp(80px, 20vw, 100px); 
                margin-bottom: 18px;
                margin-top: 5px;
                border-width: 3px;
            }
            .display-area {
                margin-bottom: 20px;
            }
            .word-slots {
                gap: 5px;
                max-width: 95vw;
            }
            .letter-slot {
                width: clamp(34px, 7.5vw, 48px);
                height: clamp(44px, 9.5vw, 58px);
                font-size: clamp(1.3rem, 3.8vw, 1.9rem);
                border-radius: 8px;
            }
            .word-slots.long-word .letter-slot {
                width: clamp(30px, 6.5vw, 42px);
                height: clamp(40px, 8.5vw, 52px);
                font-size: clamp(1.1rem, 3.2vw, 1.6rem);
            }
            .letter-tile {
                width: clamp(48px, 9.5vw, 64px);
                height: clamp(48px, 9.5vw, 64px);
                font-size: clamp(1.7rem, 4.2vw, 2.4rem);
            }
            .tile-tray.long-word .letter-tile {
                width: clamp(42px, 8.5vw, 58px);
                height: clamp(42px, 8.5vw, 58px);
                font-size: clamp(1.5rem, 3.8vw, 2.1rem);
            }
            .tile-tray {
                gap: 8px;
                padding: 15px 10px;
                border-radius: 0 0 20px 20px;
            }
        }

            /* Dragging visual state for pointer-based drag */
            .letter-tile.dragging {
                position: fixed !important;
                pointer-events: none;
                transform: none !important;
                z-index: 9999;
                box-shadow: 0 12px 30px rgba(0,0,0,0.35);
            }

            /* Prevent scrolling when class is toggled (used during drag) */
            html.no-scroll, body.no-scroll {
                overflow: hidden !important;
                touch-action: none !important;
                -ms-touch-action: none !important;
            }

            /* Utility class to lock touch scrolling while dragging */
            .no-scroll, .no-scroll * {
                touch-action: none !important;
                overscroll-behavior: none !important;
                -ms-touch-action: none !important;
                overflow: hidden !important;
            }

            /* Settings Button (Floating) */
            .settings-button {
                position: fixed;
                top: 20px;
                right: 20px;
                width: 56px;
                height: 56px;
                background: linear-gradient(145deg, var(--primary-color), #3a7bc8);
                color: white;
                border: none;
                border-radius: 50%;
                cursor: pointer;
                box-shadow: 0 4px 16px rgba(74, 144, 226, 0.4);
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.5rem;
                z-index: 1000;
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .settings-button:hover {
                transform: rotate(90deg) scale(1.1);
                box-shadow: 0 6px 20px rgba(74, 144, 226, 0.6);
            }

            .settings-button:active {
                transform: rotate(90deg) scale(0.95);
            }

            .dark .settings-button {
                background: linear-gradient(145deg, #1e3a5f, #2a4a7c);
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.6);
            }

            /* Settings Drawer */
            .settings-drawer {
                position: fixed;
                top: 0;
                right: -360px; /* Start completely off-screen */
                width: 320px;
                height: 100vh;
                height: 100dvh; /* Dynamic viewport height for mobile */
                background: linear-gradient(180deg, var(--card-light), var(--bg-color-light));
                box-shadow: -5px 0 30px rgba(0, 0, 0, 0.3);
                z-index: 1001;
                transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                display: flex;
                flex-direction: column;
                padding: 80px 24px 24px;
                overflow-y: auto;
                overflow-x: hidden;
                will-change: right; /* Optimize animation performance */
            }

            .settings-drawer.open {
                right: 0; /* Slide to visible position */
            }

            .dark .settings-drawer {
                background: linear-gradient(180deg, var(--card-dark), var(--bg-color-dark));
                box-shadow: -5px 0 30px rgba(0, 0, 0, 0.8);
            }

            /* Drawer Backdrop */
            .drawer-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                height: 100dvh; /* Dynamic viewport height */
                background: rgba(0, 0, 0, 0.5);
                z-index: 999;
                opacity: 0;
                visibility: hidden;
                pointer-events: none; /* Disable when hidden */
                transition: opacity 0.3s ease, visibility 0.3s ease;
                backdrop-filter: blur(4px);
                -webkit-backdrop-filter: blur(4px); /* Safari support */
            }

            .drawer-backdrop.visible {
                opacity: 1;
                visibility: visible;
                pointer-events: auto; /* Enable when visible */
            }

            /* Drawer Header */
            .drawer-header {
                margin-bottom: 32px;
                position: relative;
            }

            .drawer-header h2 {
                color: var(--primary-color);
                font-size: 1.8rem;
                margin: 0 0 8px 0;
                font-weight: 900;
                display: flex;
                align-items: center;
                gap: 12px;
            }

            .drawer-header p {
                color: #666;
                margin: 0;
                font-size: 0.9rem;
            }

            .dark .drawer-header p {
                color: #aaa;
            }

            /* Close Button for Drawer */
            .drawer-close-btn {
                position: absolute;
                top: -60px;
                right: 0;
                width: 40px;
                height: 40px;
                border: none;
                background: rgba(255, 255, 255, 0.9);
                border-radius: 50%;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 1.5rem;
                color: #333;
                box-shadow: 0 2px 12px rgba(0, 0, 0, 0.2);
                transition: all 0.2s ease;
                z-index: 10;
            }

            .drawer-close-btn:hover {
                background: rgba(255, 255, 255, 1);
                transform: scale(1.1);
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            }

            .drawer-close-btn:active {
                transform: scale(0.95);
            }

            .dark .drawer-close-btn {
                background: rgba(30, 58, 95, 0.95);
                color: #fff;
            }

            .dark .drawer-close-btn:hover {
                background: rgba(30, 58, 95, 1);
            }

            /* Drawer Controls */
            .drawer-control {
                background: white;
                border-radius: 16px;
                padding: 20px;
                margin-bottom: 16px;
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
                transition: transform 0.2s ease, box-shadow 0.2s ease;
            }

            .drawer-control:hover {
                transform: translateX(-4px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }

            .dark .drawer-control {
                background: var(--tile-bg-dark);
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            }

            .drawer-control label {
                display: flex;
                align-items: center;
                justify-content: space-between;
                font-weight: 600;
                color: var(--text-light);
                font-size: 1.1rem;
                cursor: pointer;
            }

            .dark .drawer-control label {
                color: var(--text-dark);
            }

            .drawer-control .control-icon {
                font-size: 1.5rem;
                margin-right: 12px;
                color: var(--primary-color);
            }

            .drawer-control .control-left {
                display: flex;
                align-items: center;
                gap: 12px;
            }

            /* Toggle Switch */
            .toggle-switch {
                position: relative;
                width: 56px;
                height: 30px;
                background: #ccc;
                border-radius: 30px;
                cursor: pointer;
                transition: background 0.3s ease;
            }

            .toggle-switch.active {
                background: var(--secondary-color);
            }

            .toggle-switch .toggle-slider {
                position: absolute;
                top: 3px;
                left: 3px;
                width: 24px;
                height: 24px;
                background: white;
                border-radius: 50%;
                transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            }

            .toggle-switch.active .toggle-slider {
                transform: translateX(26px);
            }

            /* Fullscreen Button */
            .drawer-button {
                width: 100%;
                background: linear-gradient(145deg, var(--accent-color), #d88e1c);
                color: white;
                border: none;
                padding: 16px;
                font-size: 1.1rem;
                font-weight: 700;
                border-radius: 12px;
                cursor: pointer;
                box-shadow: 0 4px 12px rgba(245, 166, 35, 0.3);
                transition: all 0.25s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                font-family: 'Inter', sans-serif;
                margin-top: auto;
            }

            .drawer-button:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 16px rgba(245, 166, 35, 0.4);
            }

            .drawer-button:active {
                transform: translateY(0);
            }

            @media (max-width: 480px) {
                .settings-drawer {
                    width: 85vw;
                    max-width: 320px; /* Don't make it too wide on landscape */
                    right: -100vw; /* Ensure completely off-screen */
                    padding: 70px 20px 20px;
                }
                
                .settings-drawer.open {
                    right: 0; /* Slide in when open */
                }
                
                .settings-button {
                    width: 50px;
                    height: 50px;
                    top: 16px;
                    right: 16px;
                    font-size: 1.3rem;
                }
                
                /* Ensure drawer elements are responsive */
                .drawer-control {
                    padding: 16px;
                    margin-bottom: 12px;
                }
                
                .drawer-header h2 {
                    font-size: 1.5rem;
                }
                
                .drawer-button {
                    padding: 14px;
                    font-size: 1rem;
                }

                /* Mobile close button positioning */
                .drawer-close-btn {
                    top: 16px;
                    right: 16px;
                    width: 36px;
                    height: 36px;
                    font-size: 1.3rem;
                }
            }
    </style>
</head>
<body>

    <div class="game-container">
        <h1><i class="fas fa-puzzle-piece" style="color: var(--accent-color);"></i> Spell It!</h1>

        <div class="display-area">
            <div id="wordEmoji" aria-hidden="true"></div>
            <img id="wordImage" alt="Word Image Placeholder" /> 
            
            <div class="word-slots-and-hint">
                <div class="word-slots" id="wordSlots">
                    <!-- Letter slots will be generated here -->
                </div>
                <!-- HINT DISPLAY AREA -->
                <div id="hintDisplay"></div>
                
                <button id="hintButton" class="hint-button">
                    <i class="fas fa-lightbulb"></i> Show Hint
                </button>
            </div>
        </div>

        <div class="tile-tray" id="tileTray">
            <!-- Draggable letter tiles will be generated here -->
        </div>
    </div>

    <!-- Settings Button (Floating) -->
    <button class="settings-button" id="settingsButton" title="Open Settings">
        <i class="fas fa-cog"></i>
    </button>

    <!-- Settings Drawer -->
    <div class="settings-drawer" id="settingsDrawer">
        <div class="drawer-header">
            <button class="drawer-close-btn" id="drawerCloseBtn" title="Close Settings">
                <i class="fas fa-times"></i>
            </button>
            <h2>
                <i class="fas fa-sliders-h"></i>
                Settings
            </h2>
            <p>Customize your learning experience</p>
        </div>

        <!-- Background Music Control -->
        <div class="drawer-control" id="musicControl">
            <label>
                <div class="control-left">
                    <i class="fas fa-music control-icon"></i>
                    <span>Background Music</span>
                </div>
                <div class="toggle-switch" id="musicToggle">
                    <div class="toggle-slider"></div>
                </div>
            </label>
        </div>

        <!-- Sound Effects Control -->
        <div class="drawer-control" id="sfxControl">
            <label>
                <div class="control-left">
                    <i class="fas fa-volume-up control-icon"></i>
                    <span>Sound Effects</span>
                </div>
                <div class="toggle-switch active" id="sfxToggle">
                    <div class="toggle-slider"></div>
                </div>
            </label>
        </div>

        <!-- Dark Mode Control -->
        <div class="drawer-control" id="themeControl">
            <label>
                <div class="control-left">
                    <i class="fas fa-moon control-icon"></i>
                    <span>Dark Mode</span>
                </div>
                <div class="toggle-switch" id="themeToggle">
                    <div class="toggle-slider"></div>
                </div>
            </label>
        </div>

        <!-- Fullscreen Button -->
        <button class="drawer-button" id="fullscreenButton">
            <i class="fas fa-expand"></i>
            <span>Enter Fullscreen</span>
        </button>
    </div>

    <!-- Drawer Backdrop -->
    <div class="drawer-backdrop" id="drawerBackdrop"></div>

    <!-- Custom Message Box for Success -->
    <div id="messageBox">
        <div class="message-content">
            <h2><i class="fas fa-star" style="color: var(--accent-color);"></i> GREAT JOB!</h2>
            <p style="font-size: 1.5rem; margin-bottom: 25px;">You correctly spelled: <strong id="successWord" style="color: var(--primary-color);"></strong></p>
            <button id="nextButton">Next Word <i class="fas fa-arrow-right"></i></button>
        </div>
    </div>

    <script>
        // --- Firebase/App ID Setup (Standard for environment compatibility) ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // --- Game Data: Expanded to A-Z using real images ---
        const WORDS = [
                    { word: "APPLE", emoji: "🍎" },     // A
                    { word: "BALL", emoji: "⚽" },      // B
                    { word: "CAT", emoji: "🐱" },       // C
                    { word: "DOG", emoji: "🐶" },       // D
                    { word: "EGG", emoji: "🥚" },       // E
                    { word: "FROG", emoji: "🐸" },      // F
                    { word: "GIRAFFE", emoji: "🦒" },   // G
                    { word: "HAT", emoji: "👒" },       // H
                    { word: "ICE CREAM", emoji: "🍦" }, // I
                    { word: "JUICE", emoji: "🧃" },     // J
                    { word: "KITE", emoji: "🪁" },      // K
                    { word: "LION", emoji: "🦁" },      // L
                    { word: "MONKEY", emoji: "🐵" },    // M
                    { word: "NEST", emoji: "🪺" },      // N
                    { word: "ORANGE", emoji: "🍊" },    // O
                    { word: "PARROT", emoji: "🦜" },    // P
                    { word: "QUEEN", emoji: "👸" },     // Q
                    { word: "RABBIT", emoji: "🐰" },    // R
                    { word: "SUN", emoji: "☀️" },       // S
                    { word: "TREE", emoji: "🌳" },      // T
                    { word: "UMBRELLA", emoji: "☂️" },  // U
                    { word: "VIOLIN", emoji: "🎻" },    // V
                    { word: "WHALE", emoji: "🐋" },     // W
                    { word: "XYLOPHONE", emoji: "🪘" }, // X
                    { word: "YACHT", emoji: "⛵" },      // Y
                    { word: "ZEBRA", emoji: "🦓" }      // Z
        ];

        /**
         * Create an SVG data URL with a centered emoji to be used as a reliable image.
         * Returns a data:image/svg+xml;utf8,... URL.
         */
        function emojiToDataURL(emoji, size = 300, bg = '#ffffff', circle = true) {
            const width = size;
            const height = size;
            const fontSize = Math.floor(size * 0.55);
            const circleBg = circle ? `<circle cx="${width/2}" cy="${height/2}" r="${width/2 - 6}" fill="${bg}" stroke="none"/>` : '';
            const svg = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns='http://www.w3.org/2000/svg' width='${width}' height='${height}' viewBox='0 0 ${width} ${height}'>\n  <rect width='100%' height='100%' fill='transparent'/>\n  ${circleBg}\n  <text x='50%' y='50%' font-family='Segoe UI Emoji, Noto Color Emoji, Apple Color Emoji, sans-serif' font-size='${fontSize}' dominant-baseline='middle' text-anchor='middle'>${emoji}</text>\n</svg>`;
            return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
        }

        let currentWordIndex = 0;
        let currentWordData = null;
        let userLetters = [];
        let draggableLetters = [];
        
        // Storage for available voices once loaded
        let availableVoices = [];

        // --- DOM Elements ---
        const wordSlotsContainer = document.getElementById('wordSlots');
        const tileTrayContainer = document.getElementById('tileTray');
        const wordImage = document.getElementById('wordImage'); 
        const wordEmoji = document.getElementById('wordEmoji');
        const messageBox = document.getElementById('messageBox');
        const nextButton = document.getElementById('nextButton');
        const successWordDisplay = document.getElementById('successWord');
        const hintButton = document.getElementById('hintButton'); 
        const hintDisplay = document.getElementById('hintDisplay'); // NEW element reference

        // --- Helper Functions ---

        /**
         * Finds and caches available TTS voices, prioritizing female/clear voices.
         */
        function initializeVoices() {
            availableVoices = window.speechSynthesis.getVoices();
        }
        
        // Listen for when voices are loaded by the browser
        if ('speechSynthesis' in window) {
            window.speechSynthesis.onvoiceschanged = initializeVoices;
        }

        /**
         * Enhanced speak function with better AI voice selection and pronunciation
         * @param {string} text The text to speak
         * @param {boolean} isLetter If true, speaks as a letter (e.g., "A", "P")
         * @param {boolean} isWord If true, speaks as a complete word with example
         */
        function speak(text, isLetter = false, isWord = false) {
            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                window.speechSynthesis.cancel();
                
                // If voices haven't loaded yet, try to load them now
                if (availableVoices.length === 0) {
                    initializeVoices();
                }

                const utterance = new SpeechSynthesisUtterance();
                utterance.lang = 'en-US';
                
                // Configure based on type
                if (isLetter) {
                    // For single letters: "A", "P", etc.
                    utterance.text = text.toUpperCase();
                    utterance.rate = 0.85; // Slightly slower for clarity
                    utterance.pitch = 1.3; // Higher pitch, child-friendly
                    utterance.volume = 1.0; // Full volume
                } else if (isWord) {
                    // For complete words with example: "Apple. A for Apple"
                    const wordData = WORDS.find(w => w.word.toLowerCase() === text.toLowerCase());
                    if (wordData && wordData.emoji) {
                        // Get the full word description
                        const description = getWordDescription(text);
                        utterance.text = `${text}. ${description}`;
                    } else {
                        utterance.text = text;
                    }
                    utterance.rate = 0.75; // Slower for full sentences
                    utterance.pitch = 1.2;
                    utterance.volume = 1.0;
                } else {
                    // For other text (hints, messages)
                    utterance.text = text;
                    utterance.rate = 0.8;
                    utterance.pitch = 1.1;
                    utterance.volume = 1.0;
                }

                // Prioritize best AI voices for children
                const preferredVoiceNames = [
                    'Google US English', // Google's natural voice
                    'Microsoft Zira', // Windows female voice
                    'Microsoft David', // Windows male voice (backup)
                    'Samantha', // macOS female
                    'Alex', // macOS male
                    'Karen', // macOS Australian
                    'female', // Any female voice
                    'Google UK English Female'
                ];
                
                let selectedVoice = null;
                for (const voiceName of preferredVoiceNames) {
                    selectedVoice = availableVoices.find(voice => 
                        voice.name.includes(voiceName) || 
                        voice.name.toLowerCase().includes(voiceName.toLowerCase())
                    );
                    if (selectedVoice) break;
                }
                
                if (selectedVoice) {
                    utterance.voice = selectedVoice;
                }

                window.speechSynthesis.speak(utterance);
            } else {
                console.warn("Text-to-speech not supported in this browser.");
            }
        }

        /**
         * Gets a child-friendly description for a word
         * @param {string} word The word to describe
         * @returns {string} Description like "A for Apple"
         */
        function getWordDescription(word) {
            const firstLetter = word.charAt(0).toUpperCase();
            const capitalizedWord = word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
            return `${firstLetter} for ${capitalizedWord}`;
        }

        /**
         * Speaks just the phonetic sound of a letter (e.g., "ah" for A, "puh" for P)
         * @param {string} letter The letter to pronounce phonetically
         */
        function speakLetterPhonetic(letter) {
            const phoneticMap = {
                'A': 'ay', 'B': 'bee', 'C': 'see', 'D': 'dee', 'E': 'ee',
                'F': 'eff', 'G': 'jee', 'H': 'aych', 'I': 'eye', 'J': 'jay',
                'K': 'kay', 'L': 'ell', 'M': 'emm', 'N': 'enn', 'O': 'oh',
                'P': 'pee', 'Q': 'cue', 'R': 'arr', 'S': 'ess', 'T': 'tee',
                'U': 'you', 'V': 'vee', 'W': 'double you', 'X': 'ex', 'Y': 'why', 'Z': 'zee'
            };
            
            const phonetic = phoneticMap[letter.toUpperCase()] || letter;
            speak(phonetic, false, false);
        }

        /**
         * Shuffles an array randomly.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- Game Logic ---

        /**
         * Loads the current word and sets up the game board.
         */
        function loadWord() {
            // Stop any ongoing speech when a new word loads
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
            }

            if (currentWordIndex >= WORDS.length) {
                // Game over for this set!
                showMessageBox("CONGRATULATIONS!", "You completed all the words!", "Start Over");
                nextButton.onclick = () => {
                    currentWordIndex = 0; // Reset
                    hideMessageBox();
                    loadWord();
                };
                return;
            }

            currentWordData = WORDS[currentWordIndex];
            const word = currentWordData.word;
            userLetters = Array(word.length).fill(null);
            
            // 1. Initial Audio: Speak "A for Apple" (e.g., first letter of the word + the word itself)
            const firstLetter = word.charAt(0);
            speak(`${firstLetter} for ${word}`);

            // 2. Update Icon/Image (Uses image URL now)
            // Render emoji SVG and set it as the image source so it always loads reliably.
            const emoji = currentWordData.emoji || '';
            // Choose emoji SVG background based on current theme
            const isDark = document.body.classList.contains('dark');
            const svgBg = isDark ? '#15202b' : '#ffffff';
            const svgDataUrl = emojiToDataURL(emoji, 300, svgBg, true);
            wordImage.onload = () => {
                wordEmoji.style.display = 'none';
                wordImage.style.display = 'block';
            };
            wordImage.onerror = () => {
                wordImage.style.display = 'none';
                wordEmoji.style.display = 'flex';
            };
            // Show the emoji fallback element while the SVG image is loading
            wordEmoji.textContent = emoji;
            wordEmoji.style.display = 'flex';
            wordImage.style.display = 'none';
            wordImage.src = svgDataUrl;

            // 3. Create Word Slots
            wordSlotsContainer.innerHTML = '';
            for (let i = 0; i < word.length; i++) {
                const slot = document.createElement('div');
                slot.className = 'letter-slot';
                slot.dataset.index = i;
                slot.dataset.correctLetter = word[i];
                
                wordSlotsContainer.appendChild(slot);
            }

            // Apply dynamic sizing for long words (7+ letters)
            if (word.length >= 7) {
                wordSlotsContainer.classList.add('long-word');
                tileTrayContainer.classList.add('long-word');
            } else {
                wordSlotsContainer.classList.remove('long-word');
                tileTrayContainer.classList.remove('long-word');
            }

            // 4. Create Draggable Tiles (Unchanged logic)
            tileTrayContainer.innerHTML = '';
            // Only provide the exact letters needed for the word to avoid confusing children
            let requiredLetters = word.split('');
            draggableLetters = shuffleArray([...requiredLetters]);

            draggableLetters.forEach((letter, index) => {
                const tile = document.createElement('div');
                tile.className = 'letter-tile';
                tile.textContent = letter;
                tile.dataset.letter = letter;
                tile.id = `tile-${index}-${letter}`;
                
                // Only use pointer events - simpler and works on all devices
                tile.addEventListener('pointerdown', handlePointerDown);
                
                tileTrayContainer.appendChild(tile);
            });
            
            // 5. Setup hint button and display
            if (hintButton) {
                // Keep it enabled for repeated use as requested
                hintButton.disabled = false;
                hintButton.onclick = showHint;
            }
            // Clear and hide hint display for the new word
            hintDisplay.textContent = '';
            hintDisplay.style.opacity = '0';

            // Reset message box state
            hideMessageBox();
        }

        /**
         * Displays the correct word as a hint without manipulating tiles.
         */
        function showHint() {
            if (!currentWordData) return;
            
            const word = currentWordData.word;

            // Play hint sound
            playHintSound();

            // 1. Display the hint in the designated area
            hintDisplay.textContent = `Hint: ${word}`;
            hintDisplay.style.opacity = '1'; // Show the hint area

            // 2. Speak the word with description for auditory reinforcement
            const description = getWordDescription(word);
            speak(`Hint. ${word}. ${description}`, false, false); 

            // IMPORTANT: The hint button is NOT disabled, and no tiles are moved.
        }


        // --- Simple Pointer-based drag (works on all devices) ---
        let activeTile = null;
        let offsetX = 0, offsetY = 0;
        let originParent = null;

        function handlePointerDown(e) {
            // Ignore if not primary button/touch
            if (e.button && e.button !== 0) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            activeTile = e.currentTarget;
            
            // Speak the letter when picked up
            const letter = activeTile.dataset.letter;
            if (letter) {
                speakLetterPhonetic(letter);
                playLetterPickupSound();
            }
            
            // Lock scrolling
            document.body.style.overflow = 'hidden';
            document.body.style.touchAction = 'none';
            
            // Record where this tile came from
            originParent = activeTile.parentElement;
            if (originParent.classList.contains('letter-slot')) {
                const idx = parseInt(originParent.dataset.index);
                userLetters[idx] = null;
            }
            
            // Get initial position
            const rect = activeTile.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            
            // Make it fixed position and draggable
            activeTile.style.position = 'fixed';
            activeTile.style.zIndex = '10000';
            activeTile.style.width = rect.width + 'px';
            activeTile.style.height = rect.height + 'px';
            activeTile.style.left = (e.clientX - offsetX) + 'px';
            activeTile.style.top = (e.clientY - offsetY) + 'px';
            activeTile.style.pointerEvents = 'none';
            activeTile.classList.add('dragging');
            
            // Move to body to escape parent constraints
            document.body.appendChild(activeTile);
            
            // Listen for move and release
            window.addEventListener('pointermove', handlePointerMove);
            window.addEventListener('pointerup', handlePointerUp);
            window.addEventListener('pointercancel', handlePointerUp);
        }

        function handlePointerMove(e) {
            if (!activeTile) return;
            e.preventDefault();
            
            activeTile.style.left = (e.clientX - offsetX) + 'px';
            activeTile.style.top = (e.clientY - offsetY) + 'px';
        }

        function handlePointerUp(e) {
            if (!activeTile) return;
            
            e.preventDefault();
            
            // Remove listeners
            window.removeEventListener('pointermove', handlePointerMove);
            window.removeEventListener('pointerup', handlePointerUp);
            window.removeEventListener('pointercancel', handlePointerUp);
            
            // Restore scrolling
            document.body.style.overflow = '';
            document.body.style.touchAction = '';
            
            // Find what's under the pointer
            activeTile.style.pointerEvents = 'none';
            const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
            activeTile.style.pointerEvents = '';
            
            const targetSlot = elementBelow ? elementBelow.closest('.letter-slot') : null;
            
            // Reset tile styles
            activeTile.style.position = '';
            activeTile.style.zIndex = '';
            activeTile.style.left = '';
            activeTile.style.top = '';
            activeTile.style.width = '';
            activeTile.style.height = '';
            activeTile.classList.remove('dragging');
            
            if (targetSlot) {
                // Move any existing tile back to tray
                const existingTile = targetSlot.querySelector('.letter-tile');
                if (existingTile && existingTile !== activeTile) {
                    tileTrayContainer.appendChild(existingTile);
                    const oldIdx = parseInt(targetSlot.dataset.index);
                    userLetters[oldIdx] = null;
                }
                
                // Place tile in slot
                targetSlot.appendChild(activeTile);
                const slotIdx = parseInt(targetSlot.dataset.index);
                const placedLetter = activeTile.dataset.letter;
                userLetters[slotIdx] = placedLetter;
                
                // Play placement sound (voice was already spoken when picked up)
                playLetterPlaceSound();
                
                checkForSuccess();
            } else {
                // Return to tray
                tileTrayContainer.appendChild(activeTile);
            }
            
            activeTile = null;
            originParent = null;
        }


        /**
         * Checks if the user has completed the word correctly.
         */
        function checkForSuccess() {
            // Check if all slots are filled
            if (userLetters.includes(null)) {
                return; // Word is not complete
            }

            const spelledWord = userLetters.join('');
            const correctWord = currentWordData.word;

            if (spelledWord === correctWord) {
                // Success! Speak the word with full description: "Apple. A for Apple"
                speak(correctWord, false, true); 
                
                // Highlight the correct letters
                const slots = wordSlotsContainer.querySelectorAll('.letter-slot');
                slots.forEach(slot => {
                    const tile = slot.querySelector('.letter-tile');
                    if(tile) {
                       tile.classList.add('correct');
                    }
                });

                // Disable hint button on success (to prevent clicking after the word is solved)
                hintButton.disabled = true;
                hintDisplay.style.opacity = '0'; // Hide the hint after success

                // Show the success message (pop up)
                showMessageBox("FANTASTIC!", `You spelled: ${correctWord}`);
                
                // Set up the button for the next word
                nextButton.onclick = handleNextWord;

            } else {
                console.log("Incorrect attempt.");
            }
        }

        /**
         * Advances the game to the next word.
         */
        function handleNextWord() {
            currentWordIndex++;
            hideMessageBox();
            loadWord();
        }

        /**
         * Shows the custom message box.
         */
        function showMessageBox(title, message, buttonText = "Next Word") {
            const messageTitle = messageBox.querySelector('h2');
            messageTitle.textContent = title;
            successWordDisplay.textContent = message;
            nextButton.textContent = buttonText;
            messageBox.style.display = 'flex';
        }

        /**
         * Hides the custom message box.
         */
        function hideMessageBox() {
            messageBox.style.display = 'none';
        }

        // --- Initialization ---
        // --- Enhanced in-browser audio (background music + SFX) ---
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let musicGain = audioContext.createGain();
        musicGain.gain.value = 0.15; // Louder, more audible background music
        musicGain.connect(audioContext.destination);

        let sfxGain = audioContext.createGain();
        sfxGain.gain.value = 0.4; // Moderate volume for sound effects
        sfxGain.connect(audioContext.destination);

        let musicPlaying = false;
        let sfxEnabled = true;
        let musicNodes = [];
        let musicInterval = null;

        // Enhanced background music - cheerful children's melody
        function startBackgroundMusic() {
            if (musicPlaying) return;
            musicPlaying = true;
            
            // Happy melody: Twinkle Twinkle pattern (C-C-G-G-A-A-G, F-F-E-E-D-D-C)
            const melody = [
                523.25, 523.25, 783.99, 783.99, 880.00, 880.00, 783.99,  // C5, C5, G5, G5, A5, A5, G5
                698.46, 698.46, 659.25, 659.25, 587.33, 587.33, 523.25   // F5, F5, E5, E5, D5, D5, C5
            ];
            let idx = 0;
            
            musicInterval = setInterval(() => {
                if (!musicPlaying) return;
                
                const now = audioContext.currentTime;
                const freq = melody[idx % melody.length];
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.type = 'triangle'; // Softer, warmer sound
                osc.frequency.setValueAtTime(freq, now);
                gain.gain.setValueAtTime(0.001, now);
                gain.gain.linearRampToValueAtTime(0.15, now + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.45);
                
                osc.connect(gain);
                gain.connect(musicGain);
                osc.start(now);
                osc.stop(now + 0.5);
                
                musicNodes.push({osc, gain});
                
                // Clean up old nodes
                if (musicNodes.length > 50) {
                    const old = musicNodes.splice(0, musicNodes.length - 30);
                    old.forEach(n => { 
                        try { n.osc.disconnect(); } catch(e){} 
                        try { n.gain.disconnect(); } catch(e){} 
                    });
                }
                idx++;
            }, 500); // Slower tempo for children
        }

        function stopBackgroundMusic() {
            musicPlaying = false;
            if (musicInterval) {
                clearInterval(musicInterval);
                musicInterval = null;
            }
            musicNodes.forEach(n => {
                try { n.osc.stop(); } catch(e){}
                try { n.osc.disconnect(); } catch(e){}
                try { n.gain.disconnect(); } catch(e){}
            });
            musicNodes = [];
        }

        // Soft pop sound when letter is placed correctly
        function playLetterPlaceSound() {
            if (!sfxEnabled) return;
            
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.exponentialRampToValueAtTime(600, now + 0.1);
            
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            
            osc.connect(gain);
            gain.connect(sfxGain);
            osc.start(now);
            osc.stop(now + 0.2);
        }

        // Soft ascending tone when letter is picked up/touched
        function playLetterPickupSound() {
            if (!sfxEnabled) return;
            
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(600, now);
            osc.frequency.exponentialRampToValueAtTime(800, now + 0.08);
            
            gain.gain.setValueAtTime(0.25, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            
            osc.connect(gain);
            gain.connect(sfxGain);
            osc.start(now);
            osc.stop(now + 0.12);
        }

        // Pleasant chime sound when hint is shown
        function playHintSound() {
            if (!sfxEnabled) return;
            
            const now = audioContext.currentTime;
            const notes = [659.25, 783.99, 1046.50]; // E5, G5, C6 - ascending
            
            notes.forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                const startTime = now + (i * 0.08);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, startTime);
                
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(0.35, startTime + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);
                
                osc.connect(gain);
                gain.connect(sfxGain);
                osc.start(startTime);
                osc.stop(startTime + 0.35);
            });
        }

        // Cheerful success melody - ascending notes
        function playSuccessSound() {
            if (!sfxEnabled) return;
            
            const now = audioContext.currentTime;
            const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6 - major chord
            
            notes.forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                const startTime = now + (i * 0.12);
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, startTime);
                
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(0.4, startTime + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);
                
                osc.connect(gain);
                gain.connect(sfxGain);
                osc.start(startTime);
                osc.stop(startTime + 0.55);
            });
        }

        // Celebratory fanfare - sounds like "yay!"
        function playCelebration() {
            if (!sfxEnabled) return;
            
            const now = audioContext.currentTime;
            
            // Create a cheerful rising melody
            const celebration = [
                {freq: 523.25, time: 0},     // C5
                {freq: 659.25, time: 0.1},   // E5
                {freq: 783.99, time: 0.2},   // G5
                {freq: 1046.50, time: 0.3},  // C6
                {freq: 1318.51, time: 0.4}   // E6
            ];
            
            celebration.forEach(note => {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                const startTime = now + note.time;
                
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(note.freq, startTime);
                
                gain.gain.setValueAtTime(0, startTime);
                gain.gain.linearRampToValueAtTime(0.5, startTime + 0.03);
                gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.4);
                
                osc.connect(gain);
                gain.connect(sfxGain);
                osc.start(startTime);
                osc.stop(startTime + 0.45);
            });
        }

        // --- Settings Drawer Functionality ---
        const settingsButton = document.getElementById('settingsButton');
        const settingsDrawer = document.getElementById('settingsDrawer');
        const drawerBackdrop = document.getElementById('drawerBackdrop');
        const drawerCloseBtn = document.getElementById('drawerCloseBtn');
        const musicToggle = document.getElementById('musicToggle');
        const sfxToggle = document.getElementById('sfxToggle');
        const themeToggle = document.getElementById('themeToggle');
        const fullscreenButton = document.getElementById('fullscreenButton');

        // Ensure drawer is closed on page load
        settingsDrawer.classList.remove('open');
        drawerBackdrop.classList.remove('visible');

        // Toggle drawer open/close
        function openDrawer() {
            settingsDrawer.classList.add('open');
            drawerBackdrop.classList.add('visible');
            // Prevent scrolling on mobile
            document.body.style.overflow = 'hidden';
            document.body.style.position = 'fixed';
            document.body.style.width = '100%';
            document.body.style.top = '0';
        }

        function closeDrawer() {
            settingsDrawer.classList.remove('open');
            drawerBackdrop.classList.remove('visible');
            // Restore scrolling on mobile
            document.body.style.overflow = '';
            document.body.style.position = '';
            document.body.style.width = '';
            document.body.style.top = '';
        }

        // Settings button - open drawer
        settingsButton.addEventListener('click', (e) => {
            e.stopPropagation();
            openDrawer();
        });

        settingsButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            openDrawer();
        });

        // Close button - close drawer
        drawerCloseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeDrawer();
        });

        drawerCloseBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeDrawer();
        });

        // Backdrop - close drawer
        drawerBackdrop.addEventListener('click', (e) => {
            e.stopPropagation();
            closeDrawer();
        });

        drawerBackdrop.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            closeDrawer();
        });

        // Escape key to close drawer
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && settingsDrawer.classList.contains('open')) {
                closeDrawer();
            }
        });

        // Prevent drawer from closing when clicking inside it
        settingsDrawer.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        settingsDrawer.addEventListener('touchend', (e) => {
            e.stopPropagation();
        });

        // Initialize theme from localStorage
        function applyTheme(theme) {
            if (theme === 'dark') {
                document.body.classList.add('dark');
                musicGain.gain.value = 0.12; // Slightly lower in dark mode
                themeToggle.classList.add('active');
            } else {
                document.body.classList.remove('dark');
                musicGain.gain.value = 0.15; // Normal volume
                themeToggle.classList.remove('active');
            }
            // Refresh current image to match the new background
            if (currentWordData) {
                const emoji = currentWordData.emoji || '';
                const svgBg = document.body.classList.contains('dark') ? '#15202b' : '#ffffff';
                wordImage.src = emojiToDataURL(emoji, 300, svgBg, true);
                wordEmoji.textContent = emoji;
            }
        }

        const savedTheme = localStorage.getItem('gameTheme') || 'light';
        applyTheme(savedTheme);

        // Theme toggle - works for both click and touch
        themeToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            const next = document.body.classList.contains('dark') ? 'light' : 'dark';
            localStorage.setItem('gameTheme', next);
            applyTheme(next);
        });

        themeToggle.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const next = document.body.classList.contains('dark') ? 'light' : 'dark';
            localStorage.setItem('gameTheme', next);
            applyTheme(next);
        });

        // Music toggle - works for both click and touch
        musicToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleMusic();
        });

        musicToggle.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleMusic();
        });

        function toggleMusic() {
            // Ensure context resumed on user gesture
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            if (!musicPlaying) {
                startBackgroundMusic();
                musicToggle.classList.add('active');
                localStorage.setItem('musicEnabled', 'true');
            } else {
                stopBackgroundMusic();
                musicToggle.classList.remove('active');
                localStorage.setItem('musicEnabled', 'false');
            }
        }

        // SFX toggle - works for both click and touch
        sfxToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleSFX();
        });

        sfxToggle.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleSFX();
        });

        function toggleSFX() {
            sfxEnabled = !sfxEnabled;
            if (sfxEnabled) {
                sfxToggle.classList.add('active');
                localStorage.setItem('sfxEnabled', 'true');
            } else {
                sfxToggle.classList.remove('active');
                localStorage.setItem('sfxEnabled', 'false');
            }
        }

        // Load saved audio preferences
        const savedMusicEnabled = localStorage.getItem('musicEnabled');
        const savedSFXEnabled = localStorage.getItem('sfxEnabled');

        if (savedMusicEnabled === 'true') {
            // User wants music - it will start on first interaction
            musicToggle.classList.add('active');
        } else if (savedMusicEnabled === 'false') {
            musicToggle.classList.remove('active');
        }

        if (savedSFXEnabled === 'false') {
            sfxEnabled = false;
            sfxToggle.classList.remove('active');
        } else {
            sfxEnabled = true;
            sfxToggle.classList.add('active');
        }

        // Fullscreen toggle
        fullscreenButton.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                // Enter fullscreen
                document.documentElement.requestFullscreen().then(() => {
                    fullscreenButton.innerHTML = '<i class="fas fa-compress"></i> <span>Exit Fullscreen</span>';
                }).catch(err => {
                    console.log('Fullscreen error:', err);
                });
            } else {
                // Exit fullscreen
                document.exitFullscreen().then(() => {
                    fullscreenButton.innerHTML = '<i class="fas fa-expand"></i> <span>Enter Fullscreen</span>';
                }).catch(err => {
                    console.log('Exit fullscreen error:', err);
                });
            }
        });

        // Listen for fullscreen changes (e.g., pressing Escape)
        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                fullscreenButton.innerHTML = '<i class="fas fa-expand"></i> <span>Enter Fullscreen</span>';
            } else {
                fullscreenButton.innerHTML = '<i class="fas fa-compress"></i> <span>Exit Fullscreen</span>';
            }
        });

        // Hook success sounds into success event
        const originalShowMessageBox = showMessageBox;
        window.showMessageBox = function(title, message, buttonText = 'Next Word') {
            if (title === "FANTASTIC!") {
                // Play celebration sounds
                playSuccessSound();
                setTimeout(playCelebration, 400);
            }
            originalShowMessageBox(title, message, buttonText);
        };

        // --- Initialization ---
        // Preload and optimize first load
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize voices early
            if ('speechSynthesis' in window && availableVoices.length === 0) {
                initializeVoices();
            }
            // Load first word immediately for instant playability
            loadWord();
        });
    </script>
</body>
</html>